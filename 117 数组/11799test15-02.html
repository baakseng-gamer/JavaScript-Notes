<script>
    // 让我们遍历数组，将当前局部元素的和保存在变量 s 中。如果 s 在某一点变成负数了，就重新分配 s=0。所有 s 中的最大值就是答案。
    // 如果文字描述不太好理解，就直接看下面的代码吧，真的很短：
    function getMaxSubSum(arr) {
        let maxSum = 0;
        let partialSum = 0;

        for (let item of arr) { // arr 中的每个 item
            partialSum += item; // 将其加到 partialSum
            maxSum = Math.max(maxSum, partialSum); // 记住最大值
            if (partialSum < 0) partialSum = 0; // 如果是负数就置为 0
        }

        return maxSum;
    }

    console.log(getMaxSubSum([-1, 2, 3, -9])); // 5
    console.log(getMaxSubSum([-1, 2, 3, -9, 11])); // 11
    console.log(getMaxSubSum([-2, -1, 1, 2])); // 3
    console.log(getMaxSubSum([100, -9, 2, -3, 5])); // 100
    console.log(getMaxSubSum([1, 2, 3])); // 6
    console.log(getMaxSubSum([-1, -2, -3])); // 0
    
    // 该算法只需要遍历 1 轮数组，所以时间复杂度是 O(n)。

    // 你也可以在这获取更多该算法的细节信息：
    // 最大子数组问题。https://en.wikipedia.org/wiki/Maximum_subarray_problem
    // 如果还是不明白，那就调试上面的例子，观察它是怎样工作的，说得再多也没有自己去调试好使。
</script>