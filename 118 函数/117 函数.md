# 117 函数

**目录**





***

# 概要

函数就是把完成特定功能的一段代码**抽象出来**，使之成为程序中的一个**独立实体**，起个名字**(函数名)**。可以在同一个程序或其他程序中多次重复使用**(通过函数名调用)**。



> 函数是程序的主要**“构建模块”**。函数使该段代码可以被调用很多次，而不需要写重复的代码。
>
> 我们已经看到了内置函数的示例，如 alert(message)、prompt(message, default) 和 confirm(question)。但我们也可以创建自己的函数。
>
> 以上来自现代JavaScript教程



# 1. 函数的分类

* **内置函数(系统函数、官方函数)**

  是官方提供好的函数，直接使用，例如：

  ```
  alert()
  document.write()
  console.log()
  parseInt() parseFloat()...
  ```

* **自定义函数**

  用户根据实际需求，需要自己封装一个函数。

* **事件驱动函数**

  * 什么是事件驱动函数？

    在和页面交互的过程中所调用的函数，该函数被称之为事件驱动函数。

  * 什么是事件？

    和页面交互的行为称之为事件。比如：鼠标点击某个按钮时(onclick)、鼠标浮动或离开到某个区域时（onmouseenter、onmouseleave）、文本框获取焦点和失去焦点时(onfocus、onblur)等



# 2. 函数定义

也叫函数声明，用function关键字定义一个

语法：

```
function 函数名(参数名1, 参数名2, ...) //函数可以没有形参
{
	语句/代码块;
	return 返回值; //可以没有返回值(undefined)
}
```

花括号为函数体，当调用该函数时，会执行函数内的代码。

**==建议：==**

* 见名思意，函数名必须体现基功能



```
<script>
    function print(){
        for(let i = 0; i < 10; i++){
            document.write("Hello Baakseng!<br />");
        }
    }
    print();//函数调用
</script>
```

实例： [11701function.html](11701function.html) 



如果再添加几个print()：

```
<script>
    function print(){
        for(let i = 0; i < 10; i++){
            document.write("Hello Baakseng!<br />");
        }
    }
    print();
    print();
    print();
</script>
```

输出结果为3个10行"Hello Baakseng"，即30行"Hello Baakseng"，print()被调用三次。

实例： [11701functionf01.html](11701functionf01.html) 



**作用：**

* 使程序变得简短而清晰
* 有利于程序维护
* 可以提高程序开发效率
* 提高了代码的重用性（复用性）



# 3. 参数

在调用函数时，可以向其传递值，这些值被称为参数。

* **形参**就是在函数定义时，函数名后面的参数，不能用var修饰。

  ```
  function f(a, b){
  	...body...
  }
  ```

* **实参**就是调用时，函数名后面的参数

  ```
  function f(){
  	...body...
  }
  f(a);
  ```



采用参数的示例：

```
<script>
    function print(n){
        for(let i = 0; i < n; i++){
            document.write("Hello Baakseng!<br />");
        }
    }
    print(5);
</script>
```

输出结果为5行"Hello Baakseng"。

实例： [11702canshu01.html](11702canshu01.html) 



两个参数使用字符串示例：

```
<script>
    function MSG(personal, text){
        document.write(personal + ": " + text + "<br />");
    }
    MSG("卡尔玛", "夏亚，你算计我"); //卡尔玛: 夏亚，你算计我
    MSG("夏亚", "啊哈哈！"); //夏亚: 啊哈哈！
    MSG(); //undefined: undefined
    MSG("Baakseng"); //Baakseng: undefined
    // MSG( , "Hi"); 出错
    MSG("Baakseng", ""); //Baakseng:
</script>
```

实例：  [11702canshu02.html](11702canshu02.html) 

当函数被调用时，给定值被复制到了局部变量personal和text。然后函数使用它们进行计算。



**==注意==**

* 在一般传值调用的机制中只能把实参传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参值发生改变，而实参中的值不会变化。

  例：

  ```
  <script>
      function addNum(n) {
          n += 5;
          document.write(n); //15
      }
      var a = 10;
      addNum(a);
      document.write(a); //10
  </script>
  ```

  实例：  [11702canshu03.html](11702canshu03.html) 

  

  还有一个例子，一个变量 from，并将它传递给函数。请注意：函数会修改 from，但在函数外部看不到更改，因为函数修改的是复制的变量值副本：

  ```
  <script>
      function showMSG(from, text){
          from = "| " + from + " |";
          document.write(from + " : " + text +"<br />"); //| Gundam | : Hello
      }
      let from = "Gundam";
      showMSG(from, "Hello");
      document.write(from); //Gundam
  </script>
  ```

  实例： [11702canshu04.html](11702canshu04.html) 



# 4. 默认值

如果未提供参数，那么其默认值则是 undefined。

示例：

```
<script>
    function msg(personal, text){
        document.write(personal + " : " + text + "<br />");
    }
    msg("Baakseng" , "I am the Gundam"); //Baakseng : I am the Gundam 两个参数
    msg("zaku" ,); //zaku : undefined
    msg();//undefined : undefined
    // msg(, "123"); 错误 Uncaught SyntaxError: Unexpected token ','
</script>
```

实例： [11703morenzhi.html](11703morenzhi.html) 

这不是错误，没有参数，程序会假定text === undefined。但是没有第一个参数（就是 , 号前面的参数）会出错。



设定参数默认，可以用 = 号指定：

```
<script>
    function msg(personal, text = "ahhh"){
        document.write(personal + " : " + text + "<br />");
    }
    msg("Gundam"); //Gundam : ahhh
</script>
```

实例： [11703morenzhi01.html](11703morenzhi01.html) 

如果text未被传递，它将会得到值"ahhh"。

text也可以是更复杂的表达式，并且只会在缺少参数时才会被计算和分配。所以，这也是可能的：

```
function msg(personal, text = anotherFunction()) {
  // anotherFunction() 仅在没有给定 text 时执行
  // 其运行结果将成为 text 的值
}
```

**==注意==**

* 在 JavaScript 中，每次函数在没带个别参数的情况下被调用，默认参数会被计算出来。
* 在上面的例子中，每次 msg() 不带 text 参数被调用时，anotherFunction() 就会被调用。



**后备的默认参数**

有些时候，将参数默认值的设置放在函数执行（相较更后期）而不是函数声明的时候，也能行得通。

为了判断参数是否被省略掉，可以拿它跟 undefined 做比较：

```
<script>
    function msg(personal, text){
        if(text === undefined){
            text = "...";
        }
        document.write(personal + " : " + text + "<br / >");
    }
    msg("Baakseng", "Hi"); //Baakseng : Hi
    msg("The man", "fuck off"); //The man : fuck off
    msg("Baakseng"); //Baakseng : ...
</script>
```

实例： [11703morenzhi02.html](11703morenzhi02.html) 

text未被传递，则得到字符串的值"..."。

或者可以使用`||`运算符：

```
<script>
    function msg(personal, text){
        text = text || "...";
        document.write(personal + " : " + text + "<br / >");
    }
    msg("Baakseng", "Hi"); //Baakseng : Hi
    msg("The man", "fuck off"); //The man : fuck off
    msg("Baakseng"); //Baakseng : ...
</script>
```

实例：  [11703morenzhi03.html](11703morenzhi03.html) 



现代 JavaScript 引擎支持 空值合并运算符 `??`，当可能遇到其他假值时它更有优势，如 0 会被视为正常值不被合并：

```
<script>
    function showCount(count){
        console.log(count ?? "unknow");
    }
    showCount(0); //0
    showCount(); //unknow
    showCount(null); //unknows
</script>
```

实例： [11703morenzhi04.html](11703morenzhi04.html) 



# 5. 返回值

有时，我们会希望函数将值返回调用它的地方。

通过使用 return 语句就可以实现。

在使用 return 语句时，函数会停止执行，并返回指定的值。

简单的例子，将两个数相加的函数：

```
<script>
    function sum(a, b){
        return a + b;
    }
    let result = sum(1, 5);
    console.log(result); //6
    console.log(sum(2, 7)); //9
</script>
```

实例： [11704fanhuizhi01.html](11704fanhuizhi01.html) 

**==注意==**

* 函数的返回值只能通过return来返回,除了return以外，没有任何声明可以表示返回值。



无论return在哪里，只要有执行了return同一条的代码后，函数立即停止，并且立即退出，因此位于return语句之后的任何代码都永远不会执行：

```
<script>
    function sum(a, b){
        return a + b;
        //取消上一行试试看
        console.log("测试代码");
    }
    document.write(sum(2, 5));//7
</script>
```

实例： [11704fanhuizhi02.html](11704fanhuizhi02.html) 



在一个函数中可能会出现很多次 `return`。例如：

```
<script>
    function checkAge(age){
        if(age >= 18){
            return true;
        }else {
            return false;
        }
    }

    let age = prompt("多大啦你？", 18);

    if(checkAge(age)){
        alert("同意访问");
    }else {
        alert("禁止访问");
    }
</script>
```

18岁以上（含18岁）同意访问，否则禁止访问。

实例：  [11704fanhuizhi03.html](11704fanhuizhi03.html) 



只使用 return 但没有返回值也是可行的。但这会导致函数立即退出。例如：

```
<script>
    let age = prompt("请输入你的年龄", 18);
    function showMSG(age){
        if(!age){ //试试去掉!号
            return;
        }
        alert("abcd")
    }
    showMSG();
</script>
```

在上述代码中，if(!age) 返回 false，那么 showMSG 将不会运行到 alert。

无论return在哪里，只要有执行了return同一条的代码后，函数立即停止，并且立即退出，因此位于return语句之后的任何代码都永远不会执行。

实例： [11704fanhuizhi04.html](11704fanhuizhi04.html) 



**==注意==**

* 空值的 return 或没有 return 的函数返回值为 undefined。示例：

  ```
  <script>
      function showNull(){    }
      console.log(typeof showNull()); //undefined
      console.log(typeof showNull); //function
      console.log(showNull() === undefined); //true
  </script>
  ```

  实例： [11704fanhuizhi05.html](11704fanhuizhi05.html) 

* 空值的 return 和 return undefined 等效。

* return只能返回一个值。如果用逗号隔开多个值，则以最后一个为准。示例：

  ```
  <script>
      function result(a, b){
          return a * b, a + b;
      }
      let fanhuizhi = result(10, 15);
      document.write(fanhuizhi); //25
  </script>
  ```

  实例：  [11704fanhuizhi06.html](11704fanhuizhi06.html) 



**==WARING==**

* 不要在 return 与返回值之间添加新行

  对于 return 的长表达式，可能你会很想将其放在单独一行，如下所示：

  ```
  return
   (some + long + expression + or + whatever * f(a) + f(b))
  ```

  但这不行，因为 JavaScript 默认会在 return 之后加上分号。上面这段代码和下面这段代码运行流程相同：

  ```
  return;
   (some + long + expression + or + whatever * f(a) + f(b))
  ```

  实际上它变成了空值。

  解决方法：

  ```
  return (
    some + long + expression
    + or +
    whatever * f(a) + f(b)
    )
  ```

  这样能正常运行。

**总结**

* 任何一个函数都有return关键字，用来导出函数内部的值；（闭包的思路）；
* return是非必须的，可以写也可以不写；如果不写，或者return后面没有值，函数的返回结果都是undefined；
* 无论return写在哪里，只要函数执行到了return这条代码了，执行完以后，立即停止执行并且跳出函数；会导致return下面的代码将不会执行；
* 推荐的做法是要么让函数始终都返回一个值，要么永远不要返回值，；否则函数有时候有返回值，有时候没有返回值，调试起来不方便。



# 6. 作用域（局部变量与全局变量）

作用域：就是起作用的范围。或者说有效范围。

## 局部变量

局部变量就是定义在函数内部的变量，这个变量只能在函数内部使用，即作用域范围只是函数内部，另外，形参也是局部变量。所以只能在函数内部访问它。

在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。

只要函数运行完毕，本地变量就会被删除。



## 全局变量

定义在函数外部的变量，这个变量在任何函数中都有效，即作用域范围是当前文件的任何地方。



**区别：**

JavaScript 变量的生命期从它们被声明的时间开始。

* 局部变量会在函数运行以后被删除。

* 全局变量会在页面关闭后被删除。



```
<script>
    let n1 = 10;
    function m1(){
        let n1 = 2;
        console.log(n1 * 2); //4
        console.log(n1); //2
    }
    m1();//输出两个console.log
    console.log(n1 + 5);//15
</script>
```

实例： [11705zuoyongyu.html](11705zuoyongyu.html) 



# 7. arguments





# 练习

**1.是否需要 “else”？**

如果参数 age 大于 18，那么下面的函数将返回 true。

否则它将会要求进行确认，并返回确认结果：

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}
```



如果 else 被删除，函数的工作方式会不同吗？

```
function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}
```

这两个变体的行为是否有区别？



**2.使用 '?' 或者 '||' 重写函数**

如果参数 age 大于 18，那么下面的函数返回 true。

否则它将会要求进行确认，并返回确认结果：

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Do you have your parents permission to access this page?');
  }
}
```

重写这个函数并保证效果相同，不使用 if，且只需一行代码。

编写 checkAge 的两个变体：

* 使用问号运算符 ?
* 使用或运算符 ||



**3.函数 min(a, b)**

写一个返回数字 a 和 b 中较小的那个数字的函数 min(a,b)。

例如：

```
min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1
```



**4.函数 pow(x,n)**

写一个函数 `pow(x,n)`，返回 `x` 的 `n` 次方。换句话说，将 `x` 与自身相乘 `n` 次，返回最终结果。

```
pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...*1 = 1
```

创建一个 web 页面，提示输入 x 和 n，然后返回 pow(x,n) 的运算结果。

P.S. 在这个任务中，函数应该只支持自然数 n：从 1 开始的整数。



**5.计算两个数字的和、差、积、商**

要求：使用传参的形式



**6.计算三个数字的大小，按从小到大顺序输出**



**7.输入n为偶数时，调用函数求1/2+1/4+...+1/n,当输入n为奇数时，调用函数求/1+1/3+...+1/n** 



**8.求最大的数**

利用函数求任意两个数的最大值

求任意三个数的最大值



